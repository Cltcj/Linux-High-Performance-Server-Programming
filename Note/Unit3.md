### 第三章 TCP协议详解

&emsp;&emsp;传输层协议主要有两个：TCP 和 UDP协议。TCP相对于 UDP 协议的特点是：面向连接的、基于字节流的、可靠的传输。使用TCP协议通信的双方必须先建立连接，然后才能开始读写，这种协议的连接是一对一的，也就是说基于广播和多播的应用程序不能使用 TCP 服务。而无连接协议UDP则非常适合广播和多播。

&emsp;**&emsp;字节流的意思**是，发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系。

&emsp;&emsp;**TCP 是可靠的**。首先，TCP采用发送应答机制，及发送端发送的每个TCP保文都需要得到接收端的应答，才认为本次传输成功。其次，TCP采用了超时重传机制，发送端在发出一个报文后启动一个定时器，如果定时时间内未收到应答，它将重发该报文段。

#### TCP 头部结构

```C++
/*TCP头定义，共20个字节*/ 
typedef struct _TCP_HEADER {
    short m_sSourPort; // 源端口号16bit 
    short m_sDestPort; // 目的端口号16bit 
    unsigned int m_uiSequNum; // 序列号32bit 
    unsigned int m_uiAcknowledgeNum; // 确认号32bit 
    short m_sHeaderLenAndFlag; // 前4位：TCP头长度；中6位：保留；后6位：标志位
    short m_sWindowSize; // 窗口大小16bit 
    short m_sCheckSum; // 检验和16bit short
    m_surgentPointer; // 紧急数据偏移量16bit 
}__attribute__((packed))TCP_HEADER, *PTCP_HEADER;
```

![image](https://user-images.githubusercontent.com/81791654/211594226-dbc8c711-942f-49a5-aa34-b155234492e2.png)

通过上图，我们将TCP头部结构进行总结：

- 源端口号和目的端口号。源端口号就是指本地端口，目的端口就是远程端口。
- **序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN）**，之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。
- 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。
- 首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。
- 标志位（6bit）：
  - URG：标志紧急指针是否有效。
  - ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。
  - PSH：提示接收端立即从缓冲读走数据。
  - RST：表示要求对方重新建立连接（复位报文段）。
  - SYN：表示请求建立一个连接（连接报文段）。
  - FIN：表示关闭连接（断开报文段）。
  - 窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。
  - 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。

#### **TCP** **连接 和 关闭的状态转移**

![image](https://user-images.githubusercontent.com/81791654/211594317-eb213938-c73b-43cb-8d81-76e12a8c7c29.png)

- **上半部分是TCP三路握手过程的状态变迁，下半部分是TCP四次挥手过程的状态变迁。**
  - **CLOSED**：起始点，在超时或者连接关闭时候进入此状态，这并不是一个真正的状态，而是这个状态图的假想起点和终点。
  - **LISTEN**：服务器端等待连接的状态。服务器经过 socket，bind，listen 函数之后进入此状态，开始监听客户端发过来的连接请求。此称为应用程序被动打开（等到客户端连接请求）。
  - **SYN_SENT**：第一次握手发生阶段，客户端发起连接。客户端调用 connect，发送 SYN 给服务器端，然后进入 SYN_SENT 状态，等待服务器端确认（三次握手中的第二个报文）。如果服务器端不能连接，则直接进入CLOSED状态。
  - **SYN_RCVD**：第二次握手发生阶段，跟 3 对应，这里是服务器端接收到了客户端的 SYN，此时服务器由 LISTEN 进入 SYN_RCVD状态，同时服务器端回应一个 ACK，然后再发送一个 SYN 即SYN+ACK 给客户端。状态图中还描绘了这样一种情况，当客户端在发送 SYN 的同时也收到服务器端的 SYN请求，即两个同时发起连接请求，那么客户端就会从 SYN_SENT 转换到 SYN_REVD 状态。
  - **ESTABLISHED**：第三次握手发生阶段，客户端接收到服务器端的 ACK 包（ACK，SYN）之后，也会发送一个 ACK 确认包，客户端进入 ESTABLISHED 状态，表明客户端这边已经准备好，但TCP需要两端都准备好才可以进行数据传输。服务器端收到客户端的 ACK 之后会从 SYN_RCVD 状态转移到 ESTABLISHED 状态，表明服务器端也准备好进行数据传输了。这样客户端和服务器端都是ESTABLISHED 状态，就可以进行后面的数据传输了。所以 ESTABLISHED 也可以说是一个数据传送状态。

- **下面看看TCP四次挥手过程的状态变迁。**
  - **FIN_WAIT_1**：第一次挥手。主动关闭的一方（执行主动关闭的一方既可以是客户端，也可以是服务器端，这里以客户端执行主动关闭为例），终止连接时，发送 FIN 给对方，然后等待对方返回ACK 。调用 close() 第一次挥手就进入此状态。
  - **CLOSE_WAIT**：接收到FIN 之后，被动关闭的一方进入此状态。具体动作是接收到 FIN，同时发送ACK。之所以叫 CLOSE_WAIT 可以理解为被动关闭的一方此时正在等待上层应用程序发出关闭连接指令。TCP关闭是全双工过程，这里客户端执行了主动关闭，被动方服务器端接收到FIN 后也需要调用 close 关闭，这个 CLOSE_WAIT 就是处于这个状态，等待发送 FIN，发送了FIN 则进入LAST_ACK 状态。
  - **FIN_WAIT_2**：主动端（这里是客户端）先执行主动关闭发送FIN，然后接收到被动方返回的 ACK后进入此状态。
  - **LAST_ACK**：被动方（服务器端）发起关闭请求，由状态2 进入此状态，具体动作是发送 FIN给对方，同时在接收到ACK 时进入CLOSED状态。
  - **CLOSING**：两边同时发起关闭请求时（即主动方发送FIN，等待被动方返回ACK，同时被动方也发送了FIN，主动方接收到了FIN之后，发送ACK给被动方），主动方会由FIN_WAIT_1 进入此状态，等待被动方返回ACK。 
  - **TIME_WAIT**：从状态变迁图会看到，四次挥手操作最后都会经过这样一个状态然后进入CLOSED状态。

#### 常见TCP的连接状态总结

- CLOSED：初始状态。
- LISTEN：服务器处于监听状态。
- SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。
- SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。
- ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。
- FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。
- CLOSE_WAIT：**（假设服务器）接收到客户机FIN包之后等待关闭的阶段。**在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。**但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，**若有，则在发送FIN包之前均为此状态。
- FIN_WAIT_2：**此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。**客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。
- LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。
- TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。

#### TCP **三次握手**

- 三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用：
  - 确认双方的接收能力和发送能力是否正常
  - 指定自己的初始化序列号为后面的可靠性传送做准备。
- **详细步骤：**
  - 初始状态：客户端处于 closed(关闭)状态，服务器处于 listen(监听) 状态。
  - 第一次握手：建立连接时，客户端向服务器发送SYN包（seq=x），请求建立连接，等待确认
  - 第二次握手：服务端收到客户端的SYN包，回一个ACK包（ACK=x+1）确认收到，同时发送一个SYN包（seq=y）给客户端
  - 第三次握手：客户端收到SYN+ACK包，再回一个ACK包（ACK=y+1）告诉服务端已经收到
  - 三次握手完成，成功建立连接，开始传输数据

#### TCP **四次挥手**

- 初始化状态：客户端和服务端都在连接状态：
- 客户端发送FIN包（FIN=1)给服务端，告诉它自己的数据已经发送完毕，请求终止连接，此时客户端不发送数据，但还能接收数据，进入FIN_WAIT_1状态。
- 服务端收到FIN包，回一个ACK包给客户端告诉它已经收到包了，此时还没有断开socket连接，而是等待剩下的数据传输完毕，此时服务器进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。
- 服务端等待数据传输完毕后，向客户端发送FIN包，表明可以断开连接，等待客户端发送最后一个ACK，，服务器进入LAST_ACK状态。
- 客户端收到后，回一个ACK包表明确认收到，等待2MSL时间，这的2MSL时间称为TIME_WAIT状态。确保服务端不再有数据发过来，然后彻底断开连接。

#### TCP 的TIME_WAIT状态


- TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。
- 对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。
- 理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

#### **TCP** **超时重传**

- **TCP可靠性中最重要的一个机制是处理数据超时和重传。**TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息；接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。

#### **TCP** **滑动窗口以及重传机制**

- **滑动窗口协议是传输层进行流控的一种措施**，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。TCP的滑动窗口解决了端到端的流量控制问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。
- TCP在发送数据时会设置一个计时器，若到计时器超时仍未收到数据确认信息，则会引发相应的超时或基于计时器的重传操作，计时器超时称为**重传超时（RTO）** 。另一种方式的重传称为快速重传，通常发生在没有延时的情况下。若TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文时，快速重传会推断出现丢包，需要重传。

#### 拥塞控制

&emsp;&emsp;TCP还有一个重要的任务，就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性，这就是所谓的拥塞控制。下面列出常见的拥塞控制算法：

1. TCP Tahoe/Reno
   - 最初的实现，包括慢启动、拥塞避免两个部分。基于重传超时（retransmission timeout/RTO）和重复确认为条件判断是否发生了丢包。
   - 两者的区别在于：
     - Tahoe算法下如果收到三次重复确认（3个ACK），就进入快重传立即重发丢失的数据包，同时将慢启动阈值设置为当前拥塞窗口的一半，将拥塞窗口设置为1MSS，进入慢启动状态；
     - Reno算法如果收到三次重复确认（3个ACK），就进入快重传，但不进入慢启动状态，而是直接将拥塞窗口减半，进入拥塞控制阶段，这称为“快恢复”。 
     - Tahoe和Reno算法在出现RTO时的措施一致，都是将拥塞窗口降为1个MSS，然后进入慢启动阶段。
   - **慢启动算法 – Slow Start**
     - 所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。
     - 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。
     - 每当收到一个ACK，cwnd大小加一，呈线性上升。
     - 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。
     - 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”
   - **拥塞避免算法 – Congestion Avoidance**
     - 如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：
       - 收到一个ACK，则cwnd = cwnd + 1 / cwnd
       - 每当过了一个往返延迟时间RTT，cwnd大小加一。
       - 过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。

2. TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）
   - BBR是由Google设计，于2016年发布的拥塞算法。**以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而BBR则基于模型主动探测。**该算法使用网络最近出站数据分组当时的最大带宽和往返时间来建立网络的显式模型。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法，例如CUBIC。
